// This can be separated to different files in larger applications, for different pages or parts, such as shops, profile
// This is also one file which has the same functionality from props in react
import React, { createContext, useReducer } from 'react' //Global reducer is needed as well along with this
import axios from 'axios'
import AppReducer from './AppReducer'
//Initial State
const initialState = {
    transactions:  [
        //   { id: 1, text: 'Flower', amount: -20 },
        //   { id: 2, text: 'Salary', amount: 300 },
        //   { id: 3, text: 'Book', amount: -10 },
        //   { id: 4, text: 'Camera', amount: 150 }
        ], // Sample Data
        error: null, // for knowing the error in the side of state - initially null for now
        loading: true // It initially is true, and once the request and response is done it will be false
        // loading uses a spinner component
}

// Global states will go inside the object we created above
// As long as we have access to "transactions" by components, we can do calculations there
// No need to do it in state, and the state is just for passing data. 
// Meanwhile, "actions" are for the functionalities such as deleting a transaction


// CREATE CONTEXT
// It will be used in different components
export const GlobalContext = createContext(initialState)

//Provider export for wrap around App.js components
export const GlobalProvider = ({ children }) => {
    const [state, dispatch] = useReducer(AppReducer, initialState)

    //Actions - GET DELETE AND ADD
    async function getTransactions(){
        try{
            const res = await axios.get('/api/v1/transactions') // It already has proxy so it'll be able to understand the route from the backend and able to make requests
            //from the frontend to to the backend api route/url we created
            //This will contain the response from the get request we made from the backend
            // Will be used to gather the whole data


            //Dispatch changes the state, so we're gonna use that for this action
            // The response will be inside the dispatch
            dispatch({
                type: 'GET_TRANSACTIONS',
                payload: res.data.data //data is specified here which is the data array
            })
        }
        catch(err){
            dispatch({
                type: 'TRANSACTION_ERROR',
                payload: err.response.data.error 
                // Reads the catch block of the response, and reads the error which contains the server error message
            })
        }
    }
    // This has more data since the database is connected through axios

    async function deleteTransaction(id){
        try{
            //Backend
            await axios.delete(`/api/v1/transactions/${id}`)

            //Frontend
            dispatch({
                type: 'DELETE_TRANSACTION', // Identifies the type through a descriptive name
                payload: id // The data to be passed, which is a unique id
                //This will delete specific data from the state
            })

            //The very same data that passed through and filtered out in the UI is also deleted from the database
        }
        catch(err){
            dispatch({
                type: 'TRANSACTION_ERROR',
                payload: err.response.data.error 
                // Reads the catch block of the response, and reads the error which contains the server error message
            })
        }
   
    }

    async function addTransaction(transaction){ // It would be transaction instead
        //of an ID because it takes in the whole data

    const config = {
        headers: {
            'Content-Type': 'application/json'
        }
    }
    try{
        const res = await axios.post('/api/v1/transactions', transaction, config) // It will take in data from the state in the addTransaction parameter
        // The third parameter is the config needed to be specified
        dispatch({
            type: 'ADD_TRANSACTION',
            payload: res.data.data 
            // Entire object
            // The payload should always be what is passed, since that is the data

            //BUT

            //As for this situation with the database, it should have the complete data object itself which is res.data.data instead of the transaction being the data passed,
            //Since the data passed should have an id, which is data generated by the result
        })

    }
    catch(err){
        dispatch({
            type: 'TRANSACTION_ERROR',
            payload: err.response.data.error 
            // Reads the catch block of the response, and reads the error which contains the server error message
        })
    }
       
    }

    
    return (<GlobalContext.Provider value = {{
        transactions: state.transactions,
        error: state.error,
        loading: state.loading,
        getTransactions,
        deleteTransaction,
        addTransaction
    }}>
        {children}
    </GlobalContext.Provider>)
}

//The provider wraps around the components, and the children are the components since they are wrapped around this provider
//Dispatch is for actions

//Basically, the provider doesn't only wrap around the components, but it also provides the state, actions (from dispatch), and the reducer to all the components